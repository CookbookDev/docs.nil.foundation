import Flows from '@site/static/img/nil/flows.png'

# Principles

This page offers a high-level explanation of the architecture of =nil;.

## Flows

The following diagram shows how =nil; organizes execution shards, the main shard, the transfer of ZKPs, and communications with Ethereum.

<img src={Flows}/ >

In brief, each execution shard is responsible for generating a ZKP for their respective state change. Then the proofs are verified via a [**HotStuff2-based**](https://eprint.iacr.org/2023/397.pdf) global consensus protocol. 

The main shard uses all received ZKPs to create a 'master' ZKP that is then transmitted to Ethereum. The global state of =nil; is verified and transactions reach finality.

## Consensus shard

The consensus shard performs two essential functions:

* The shard stores and sets consensus rules and parameters
* The shard stores hashes of the most recent blocks from execution shards and ensures synchronization between execution shards

:::info

There is only one consensus shard in the cluster.

:::

## Execution shards

As implied by their name, execution shards process transactions. 

Each shard is allocated with a subset of accounts from the global state. The shard is responsible for executing transactions made to and from these accounts. Consensus is handled by a committee made up of several validators.

:::info[Block capacity]

Execution shards have a preset block capacity determined by the consensus shard. If a shard reaches capacity, it is split into two. If at least half of the available capacity is vacant, the shard is merged with another shard.

:::

:::info[Validator rotation]

At the end of each epoch, a new set of validators is generated for each execution shard based on the Verifiable Secret Sharing (VSS) scheme.

:::

## Cross-shard communication

Instead of handling cross-shard communication via bridges (which are often insecure and unstable), =nil; integrates such communications in its protocol.

Each group of validators (a committee) is responsible for overseeing a particular group of shards (a neighborhood). A committee regularly monitors the messages that are made to and from accounts within a neighborhood. 

If the committee tracks an ongoing message, it must compute the shard where the message should go based on the information included in the message. If this shard is the same as the shard where the message is currently located, the message must be included in the block currently produced by the shard.

## Contract co-location

=nil; also offers participants the option of contract co-location, which is a consistent way to ensure that two accounts are always located within the same shard.

Co-location provides the fastest possible transaction speeds by eliminating the need for sending outgoing messages. However, note that using contract co-location incurs ownership and economic restrictions.