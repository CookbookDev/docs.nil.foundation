# Handling async execution

To support [**cross-shard communication**](../../principles#cross-shard-communication), =nil; supports smart contracts making async calls to one another directly in Solidity code. 

This tutorial provides a brief theoretical and practical primer on async execution, and gives suggestions on how this feature can be integrated into an application.

## Explanation

Consider a smart contract with the following code:

```sol
import "./nil.sol";

contract Caller {

    using nil for address; 

    event CallCompleted(address indexed dst)

    function call(address dst) public payable {
        dst.async_call(gasleft(), msg.value, abi.encodeWithSignature("funcName"));
        emit CallCompleted(dst);
    }
}
```

The `address.async_call()` function makes it possible for the contract to call a function in another smart contract regardless of the shard where this contract is located. There are no additional actions required for making async calls: simply adding `address.async_call()` and specifying its arguments is sufficient.

:::info

The `address.async_call()` function is a shortcut for executing a precompiled contract responsible for managing async calls across the cluster.

:::

:::info[Async calls on the same shard]

`address.async_call()` works even if the contract with the specified address is located on the same shard. The mechanism remains exactly the same as with cross-shard communications: the function will produce a new transaction, and the requested function in another contract will be executed whenever said transaction is processed by the shard. 

:::


## Examples

Consider two contracts deployed on two different shards in =nil;:

* Contract 1 (caller) is deployed on Shard 1
* Contract 2 (receiver) is deployed on Shard 2

There are two possible patterns for cross-shard communication between Contract 1 and Contract 2.

### Calling a contract on another shard

In this pattern, Contract 1 simply calls a function in Contract 2 without receiving a result.

Contract 1 has the following structure:

```sol
import "./nil.sol";

contract Caller {

    using nil for address; 

    event CallCompleted(address indexed dst)

    function call(address dst) public payable {
        dst.async_call(gasleft(), msg.value, abi.encodeWithSignature("increment()"));
        emit CallCompleted(dst);
    }
}
```

Contract 2 has the following structure:

```solidity
contract Receiver {

    uint256 private value;

    function increment() public {
        value += 1;
        emit ValueChanged(value);
    }

    function getValue() public view returns (uint256) {
        return value;
    }
}
```

Whenever the `call()` function is called inside Contract 1, a new transaction is created. When Shard 2 picks up this transaction and executes it, Contract 2 calls its `increment()` function. After `getValue()` is called, the result should display the total number of times the `call()` function was executed by Contract 1.

### Callback pattern

In this pattern, Contract 1 calls a function inside Contract 2 that makes an async call back to Contract 1.


## Additional practices

=nil; adds two Solidity function modifiers:

* `onlyInternal`. If this modifier is added, the function can only be called synchronously.
* `onlyExternal`. If this modifier is added, the function can only be called asynchronously.

If a function has the `onlyInternal` modifier, it can be called by the contract where this function is declared and other contracts existing on the same shard (if the function is public). A function with the `onlyExternal` modifier behaves the opposite way: it must be called either by a contract on a different shard or by a contract on the same shard but via the `async_call()` function.

Consider the below examples. Contract 1 is a basic contract for voting:

```solidity
import "./nil.sol";

contract Elections {

    using nil for address; 

    mapping(string => uint256) public votes;

    function requestVote(address dst, string candidate) onlyInternal public {
        dst.async_call(gasleft(), msg.value, abi.encodeWithSignature("verify_vote(string)", candidate));
        emit CallCompleted(dst);
    }

    function addVote(string candidate) onlyExternal public {
        votes[candidate]++;
    }
}
```

Contract 2 holds some verification logic:

```solidity
import "./nil.sol";

contract Verifier {

    using nil for address; 

    mapping(string => bool) 

    function verifyVote(address dst, string candidate) onlyExternal public {
        if candidate 
        dst.async_call(gasleft(), msg.value, abi.encodeWithSignature("verify_vote(string)", candidate));
        emit CallCompleted(dst);
    }
}
```





