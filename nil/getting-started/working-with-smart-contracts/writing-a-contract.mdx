# Writing a contract

This tutorial explains how to create smart contracts that take full advantage of the unique features of =nil;.

## Specification

The tutorial defines two contracts.

Contract 1 acts as a product manufacturer for a retailer. It has the following features:

* It can [**accept external messages and verify them**](../essentials/receiving-ext-messages)
* It will [**limit what messages can call**](../../tools/sol-library/func-modifiers) some of its functions

Contract 2 is a retailer. The contract can order Contract 1 to order new products by making an async call.

## Creating the first contract

Contract 1 has some basic architecture in place representing products:

```solidity showLineNumbers
pragma solidity ^0.8.0;

import "./Nil.sol";

contract Manufacturer {
    using Nil for address;

    struct Product {
        uint id;
        string name;
    }

    mapping(uint => Product) public products;
    uint public nextProductId;
}
```

The contract saves its owner on initialization:

```solidity showLineNumbers
contract Manufacturer {
    address private owner;
    constructor() {
        owner = msg.sender;
    }
}
```

The contract also stores the address of the retailer contract, which is set via a separate external message. As soon as this external message arrives, the contract stops accepting external messages:

```solidity showLineNumbers
contract Manufacturer {
    address private retailerContractAddress;
    bool private isRetailerAddressSet = false;

    function verifyExternal(uint256 messageHash, bytes authData) external view returns (bool) {
        if (isRetailerAddressSet == false) {
            return true;
        }
        return false;
    }

    function setRetailerContractAddress(address _retailerContractAddress) public {
        if (isRetailerAddressSet == false) {
            retailerContractAddress = _retailerContractAddress;
            isRetailerAddressSet = true;
        }    
    }
}
```

Last but not least, Contract 1 can produce new products (but only via an internal message):

```solidity showLineNumbers
contract Manufacturer {
    function createProduct(string calldata name) public onlyInternal {
        if (msg.sender == retailerContractAddress) {
            products[nextProductId] = Product(nextProductId, name);
            nextProductId++;
        }  
    }
}
```

Here is the full code of Contract 1:

```solidity showLineNumbers
pragma solidity ^0.8.0;

import "./Nil.sol";

contract Manufacturer {
    using Nil for address;

    struct Product {
        uint id;
        string name;
    }

    mapping(uint => Product) public products;
    uint public nextProductId;

    address private owner;
    address private retailerContractAddress;

    bool private isRetailerAddressSet = false;

    constructor() {
        owner = msg.sender;
    }

    function setRetailerContractAddress(address _retailerContractAddress) public {
        if (isRetailerAddressSet == false) {
            retailerContractAddress = _retailerContractAddress;
            isRetailerAddressSet = true;
        }    
    }

    function createProduct(string calldata name) public onlyInternal {
        if (msg.sender == retailerContractAddress) {
            products[nextProductId] = Product(nextProductId, name);
            nextProductId++;
        }  
    }

    function verifyExternal(uint256 messageHash, bytes authData) external view returns (bool) {
        if (isRetailerAddressSet == false) {
            return true;
        }
        return false;
    }
}
```

## Creating the second contract

The second contract is much simpler than the first. The `Retailer` contract orders products from the `Manufacturer` by calling it asynchronously:

```solidity showLineNumbers
pragma solidity ^0.8.0;

import "./Nil.sol";

contract Retailer {
    using Nil for address;

    function orderProduct(address dst, string calldata productName) public {
        dst.asyncCall(dst, 10000, false, 1000, abi.encodeWithSignature("createProduct(name)", productName));
    }
}
```

## Compiling the contracts

Compile Contract 1 with:

```bash
solc ./Manufacturer.sol --bin --abi -o ./Manufacturer
```

Compile Contract 2 with:

```bash
solc ./Retailer.sol --bin --abi -o ./Retailer
```

After compiling both contracts, they should be [**ready for deployment**](./deploying-a-contract)!