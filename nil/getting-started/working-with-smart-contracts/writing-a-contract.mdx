# Writing a contract

This tutorial explains how to create smart contracts that take full advantage of the unique features of =nil;.

## Specification

The tutorial defines two contracts.

Contract 1 acts as a product manufacturer for a retailer. It has the following features:

* It can [**accept external messages and verify them**](../essentials/receiving-ext-messages)
* It will [**limit what messages can call**](../../tools/sol-library/func-modifiers) some of its functions

Contract 2 is a retailer. The contract can order Contract 1 to order new products by making an async call.

## Creating the first contract

Contract 1 has some basic architecture in place representing products:

```solidity showLineNumbers
pragma solidity ^0.8.0;

import "./Nil.sol";

contract Manufacturer {
    using Nil for address;

    struct Product {
        uint id;
        string name;
    }

    mapping(uint => Product) public products;
    uint public nextProductId;
}
```

Contract 1 also stores its owner's `pubkey` and `address`, which is useful to limit access to some of its functions:

```solidity showLineNumbers
    bytes pubkey;
    address owner;

    constructor(bytes memory _pubkey, address _owner) payable {
        pubkey = _pubkey;
        owner = _owner;
    }
```

The contract also stores the address of the retailer contract, which is set via a separate message. As soon as this message arrives, the contract stops accepting external messages and prevents anyone from changing the address of the retailer. Note that only the contract owner can send external messages to the contract:

```solidity showLineNumbers
contract Manufacturer {
    address private retailerContractAddress;
    bool private isRetailerAddressSet = false;

    function verifyExternal(uint256 messageHash, bytes memory authData) external view returns (bool) {
        if (isRetailerAddressSet == false) {
            if (Nil.validateSignature(pubkey, messageHash, authData)) {
                return true;
            }
        }
        return false;
    }

    function setRetailerContractAddress(address _retailerContractAddress) public {
        if (isRetailerAddressSet == false && msg.sender == owner) {
            retailerContractAddress = _retailerContractAddress;
            isRetailerAddressSet = true;
        }
    }
}
```

Last but not least, Contract 1 can produce new products (but only via an internal message):

```solidity showLineNumbers
function createProduct(string calldata name) public onlyInternal {
        if (msg.sender == retailerContractAddress) {
            products[nextProductId] = Product(nextProductId, name);
            nextProductId++;
        }  
    }
```

Contract 1 can also output the products that have been ordered by the retailer:

```solidity showLineNumbers
function getProducts() public view returns (uint[] memory, string[] memory) {
        uint[] memory ids = new uint[](nextProductId);
        string[] memory names = new string[](nextProductId);

        for (uint i = 0; i < nextProductId; i++) {
            Product storage product = products[i];
            ids[i] = product.id;
            names[i] = product.name;
        }

        return (ids, names);
    }
```

Here is the full code of Contract 1:

```solidity showLineNumbers
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./Nil.sol";

contract Manufacturer is NilBase {
    using Nil for address;

    bytes pubkey;
    address owner;

    constructor(bytes memory _pubkey, address _owner) payable {
        pubkey = _pubkey;
        owner = _owner;
    }

    struct Product {
        uint id;
        string name;
    }

    mapping(uint => Product) public products;
    uint public nextProductId;

    address private retailerContractAddress;

    bool private isRetailerAddressSet = false;

    function setRetailerContractAddress(address _retailerContractAddress) public {
        if (isRetailerAddressSet == false && msg.sender == owner) {
            retailerContractAddress = _retailerContractAddress;
            isRetailerAddressSet = true;
        }
    }

    function getOwner() public view returns (address) {
        return owner;
    }

    function createProduct(string calldata name) public onlyInternal {
        if (msg.sender == retailerContractAddress) {
            products[nextProductId] = Product(nextProductId, name);
            nextProductId++;
        }  
    }

    function verifyExternal(uint256 messageHash, bytes memory authData) external view returns (bool) {
        if (isRetailerAddressSet == false) {
            if (Nil.validateSignature(pubkey, messageHash, authData)) {
                return true;
            }
        }
        return false;
    }

    function getProducts() public view returns (uint[] memory, string[] memory) {
        uint[] memory ids = new uint[](nextProductId);
        string[] memory names = new string[](nextProductId);

        for (uint i = 0; i < nextProductId; i++) {
            Product storage product = products[i];
            ids[i] = product.id;
            names[i] = product.name;
        }

        return (ids, names);
    }
}
```

## Creating the second contract

The second contract is much simpler than the first. The `Retailer` contract orders products from the `Manufacturer` by calling it asynchronously:

```solidity showLineNumbers
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./Nil.sol";

contract Retailer {
    using Nil for address;

    function orderProduct(address dst, string calldata productName) public {
        dst.asyncCall(msg.sender, msg.sender, 100000, false, 100000 * 10, abi.encodeWithSignature("createProduct(string)", productName));
    }
}
```

## Compiling the contracts

Compile Contract 1 with:

```bash
solc ./Manufacturer.sol --bin --abi -o ./Manufacturer
```

Compile Contract 2 with:

```bash
solc ./Retailer.sol --bin --abi -o ./Retailer
```

After compiling both contracts, they should be [**ready for deployment**](./deploying-a-contract)!