# Key components and tools

## zkLLVM Components

The architecture of zkLLVM is modular and extendable. It can be divided into three main components.

### Frontends

Frontends parse high-level languages and generate abstract syntax trees (ASTs). Presently, zkLLVM supports C++ and Rust as frontends based on `clang` and `rustc`, respectively.

:::info[zkLLVM and LLVM]

In comparison to the vanilla LLVM project frontends, zkLLVM frontends generate ASTs that are compatible with the zkSNARK circuit generation process. These ASTs include additional types and metadata.

:::

### Circifier

`circifier` receives an AST and converts it into an intermediate representation (IR) of a circuit while applying circuit-specific optimizations.

### Assigner

`assigner` transforms an AST into two products.

- The assignment table
- Arithmetization-specific constraints

:::info

Constraints flatten a computation into an arithmetization (e.g., R1CS or PLONK). An arethmitization is a set of constraints imposed by a proof system input type.

It is only necessary to generate constraints once per per every circuit/input type pair. In contrast, the assignment table needs to be regenerated whenever dynamic inputs change.

:::

Together, these products ensure that the circuit can be proven with dynamic inputs.

<details>
<summary>Click here to learn more about assigner extendibility</summary>
<p>
The core of <code>assigner</code> is an LLVM IR parser, which can be ported into any programming language. To access its current implementation, [**click here**](https://github.com/NilFoundation/zkllvm-assigner). This implementation is written in 
</p>
</details>

## Proof system components

There are two additional components provided by a proof system rather than zkLLVM.

- A prover used for generating circuit-specific proofs
- A verifier used for verifying circuit-specific proofs

:::info[Verifier]

Depending on the proof system, a verifier can be located either on-chain or off-chain.

:::

:::info[Proof systems and arithmetizations]

Note that the same arithmetization can be used several different proof systems. As a result, the constraints generated by `assigner` for one arithmetization can be freely reused across various proof systems.

:::

:::info

## Extending zkLLVM for new arithmetizations and proof systems

As mentioned above, zkLLVM is designed to be extendable. In order to add support for a new arithmetization, one has to implement only the `assigner` component of the system. It can be implemented in any language, since the core of the `assigner` component is an LLVM IR parser and can be easily ported to any language.

Current `assigner` implementation is written in C++ and can be found [here](https://github.com/NilFoundation/zkllvm-assigner) and is only for PLONK with custom gates arithmetization. We are working on the new version of the `assigner` component, which will be written in Rust and will be more generic and will support more arithmetizations. Let's look how the implementation process of this new version will look:

- First, we will implement the LLVM IR parser in Rust. This can be done from scratch or by porting the existing C++ implementation. Or we can use the existing LLVM IR parser from the [inkwell](https://github.com/TheDan64/inkwell) and extend it with the custom types and built-ins.
- Then the rest of assigner logic needs to be implemented. This can be done using an existing RUST PLONK components library, like the components from [halo2](https://github.com/zcash/halo2). You need to solve the following tasks in order to implement minimal assigner for your arithmetization:
  - Assignment table generation
  - Constraints generation
  - Constraints serialization

:::info

An arithmetization is not limited to only one proof system. For example, there are a lot of proof systems with PLONKish arithmetizaion, and the same circuit can be used with all of them. But implementation of the custom `assigner` may be required in case if you work on your own proof system or optimize the existing one. In that case the parameters of the arithmetization might change and the circuit generation has to be adjusted accordingly.

:::

You may have noticed, that we only mentioned the `assigner` component, but not the `circifier`. The reason for that is that the `circifier` is not arithmetization-specific and can be used for any arithmetization. It generates the intermediate representation for any circuit generation related process, and the `assigner` component is responsible for the conversion of the intermediate representation into the arithmetization-specific constraints and assignment table.
