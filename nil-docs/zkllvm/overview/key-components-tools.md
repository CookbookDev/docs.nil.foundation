# Key components and tools

## zkLLVM Components

The architecture of zkLLVM is modular and extendable. It can be divided into three main components.

### Frontends

Frontends parse high-level languages and generate abstract syntax trees (ASTs). Presently, zkLLVM supports C++ and Rust as frontends based on `clang` and `rustc`, respectively.

:::info[zkLLVM and LLVM]

In comparison to the vanilla LLVM project frontends, zkLLVM frontends generate ASTs that are compatible with the zkSNARK circuit generation process. These ASTs include additional types and metadata.

:::

### Circifier

`circifier` receives an AST and converts it into an intermediate representation (IR) of a circuit while applying circuit-specific optimizations.

### Assigner

`assigner` transforms an AST into two products.

- The assignment table
- Arithmetization-specific constraints

:::info

Constraints flatten a computation into an arithmetization (e.g., R1CS or PLONK). An arithmitization is a set of constraints imposed by a proof system input type.

It is only necessary to generate constraints once per per every circuit/input type pair. In contrast, the assignment table needs to be regenerated whenever dynamic inputs change.

:::

Together, these products ensure that the circuit can be proven with dynamic inputs.

<details>
<summary>Click here to learn more about assigner extendibility</summary>
<p>
The core of <code>assigner</code> is an LLVM IR parser, which can be ported into any programming language. To access its current implementation, [**click here**](https://github.com/NilFoundation/zkllvm-assigner). This implementation is written in C++ and supports only the PLONK arithmetization.
</p>
<p>
<code>assigner</code> can be extended to support any other arithmetization. This process involves implementing the LLVM IR parser and following these steps.
<ul>
<li>Find a suitable components library for the chosen arithmetization (such as <strong><a href="https://github.com/zcash/halo2">halo2</a></strong> for Rust)</li>
<li>Use the components library to implement assignment table generation</li>
<li>Use the components library to implement constraints generation and serialization</li>
</ul>
</p>
<p>
Note that there is no need to use the LLVM IR parser from the current implementation of <code>assigner</code>. Any third-party LLVM IR parser such as <strong><a href="https://github.com/TheDan64/inkwell">Inkwell</a></strong> can be used instead.
</p>
</details>

:::info[Circifier]

`circifier` prepares IRs that are compatible with any arithmetization. As a result, this component can be reused with any custom `assigner`.

:::

## Proof system components

There are two additional components provided by a proof system rather than zkLLVM.

- A prover used for generating circuit-specific proofs
- A verifier used for verifying circuit-specific proofs

:::info[Verifier]

Depending on the proof system, a verifier can be located either on-chain or off-chain.

:::

:::info[Proof systems and arithmetizations]

Note that the same arithmetization can be used by several different proof systems. As a result, constraints generated by `assigner` for one arithmetization can be freely reused across various proof systems.

:::
