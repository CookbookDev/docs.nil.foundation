import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'

# Limitations

There are several limitations on what can be included in a circuit.

## Pure functions

As circuits are composed of polynomials, functions used in circuit development cannot have any side-effects.

:::info[Pure functions]

As pure functions only depend on their arguments, they cannot make network requests, perform file system operations, or depend on any runtime states.

:::

Consider the following examples of pure functions and functions with side effects.

<Tabs groupId='language'>
  <TabItem value='cpp' label='C++'>
    ```cpp
    int a = 10;
    int function_with_side_effects(int x) {
      a += 5;
      return x*2;
    }

    int pure_function(int a, int b, int c) {
      int const constant = 11;
      return c * c * c / (b - a) + constant;
    }
    ```
  </TabItem>
  <TabItem value='rust' label='Rust'>
    ```rust
    let mut a: i32 = 10;
    fn function_with_side_effects(x: i32, a: &mut i32) -> i32 {
      a += 5;
      x*2
    }

    fn pure_function(a: i32, b: i32, c: i32) {
      let constant: i32 = 11;
      c * c * c / (b - a) + constant
    }
    ```
  </TabItem>
</Tabs>

## Passing arguments by value

Circuit functions accept arguments from [**public and private input files**](../getting-started/preparing-input-files). These arguments cannot contain memory addresses as there is no guarantee that an address would be valid when a circuit is eventually run.

As a result, arguments passed to circuit functions should be passed by value rather than by reference. 

The following examples contain examples of passing by value and passing by reference.

<Tabs groupId='language'>
  <TabItem value='cpp' label='C++'>
    ```cpp
    bool passing_by_reference(int *x) {}

    bool passing_by_value(int x) {}
    ```
  </TabItem>
  <TabItem value='rust' label='Rust'>
    ```rust
    fn passing_by_reference(x: &mut i32) -> bool {}

    fn passing_by_value(x: i32) -> bool {}
    ```
  </TabItem>
</Tabs>

## Dynamic loops

Dynamic loops are loops where the the cycle upper boundary is not necessarily known at compile time.

<Tabs groupId='language'>
  <TabItem value='cpp' label='C++'>
    ```cpp
    [[circuit]] int circuit_funct(int a, int b) {
        for (int j=0; j < b; j++) {
            a *= a;
        }

        return a
    }
    ```
  </TabItem>
  <TabItem value='rust' label='Rust'>
    ```rust
    #[circuit]
    pub fn cirucit_func(a: i32, b: i32) {
        for i in 0..b {
            a *= a;
        }
        a
    }
    ```
  </TabItem>
</Tabs>

Dynamic loops must be replaced with static loops where the upper boundary is a literal or otherwise a value known at compile time.

<Tabs groupId='language'>
  <TabItem value='cpp' label='C++'>
    ```cpp
    [[circuit]] int circuit_funct(int a) {
        for (int j=0; j < 10; j++) {
            a *= a;
        }

        return a
    }
    ```
  </TabItem>
  <TabItem value='rust' label='Rust'>
    ```rust
    #[circuit]
    pub fn cirucit_func(a: i32) {
        for i in 0..10 {
            a *= a;
        }
        a
    }
    ```
  </TabItem>
</Tabs>